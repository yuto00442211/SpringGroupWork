<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
        body {
            margin: 0;
        }

        canvas {
            background: #001f3f;
            display: block;
            margin: 0 auto;
        }
    </style>
</head>

<body>
    <canvas id="gameCanvas" width="800" height="600"></canvas>
    <button id="戻る" style="display: block; margin: 20px auto;">Restart Game</button>
    <script>
    
    document.getElementById('戻る').addEventListener('click', function() {
    window.location.href = '/afterLogin/sell';  // '遷移先のURL'の部分を実際のURLに置き換えてください。
});
        const canvas = document.getElementById('gameCanvas');
        const context = canvas.getContext('2d');

        let playerX = 50;
        let playerY = canvas.height - 50;
        let playerSize = 30;
        let playerSpeed = 3;
        let gravity = 1;
        let velocityY = 0;
        let isJumping = false;
        let isDucking = false;
        let obstacles = [];
        let keys = {};
        let obstacleTimer = 0;
        let obstacleInterval = 100;  // 障害物が出現する間隔

        let angle = 0;
        const HILL_AMPLITUDE = 50;
        const HILL_SPEED = 0.02;

        let backgroundX1 = 0;

        let background = new Image();
background.src = "/forest.jpg"; // 画像のパスを適切に設定してください
background.onload = function() {
    gameLoop();  // 画像が読み込まれてからゲームループを開始
};
let backgroundX2 = canvas.width;

function drawBackground() {
    // Draw the two instances of the background image
    context.drawImage(background, backgroundX1, 0, canvas.width, canvas.height);
    context.drawImage(background, backgroundX2, 0, canvas.width, canvas.height);

    // Move the images to the left
    backgroundX1 -= 1; 
    backgroundX2 -= 1; 

    // When the first image goes out of the screen, reset its position to the right of the second image
    if (backgroundX1 <= -canvas.width) {
        backgroundX1 = backgroundX2 + canvas.width;
    }

    // When the second image goes out of the screen, reset its position to the right of the first image
    if (backgroundX2 <= -canvas.width) {
        backgroundX2 = backgroundX1 + canvas.width;
    }
}

        function getHillY(x) {
            return HILL_AMPLITUDE * Math.sin((x + angle) * HILL_SPEED);
        }

        document.addEventListener('keydown', (e) => { keys[e.code] = true; });
        document.addEventListener('keyup', (e) => { keys[e.code] = false; });

        function update() {
            if (keys['ArrowLeft']) playerX -= playerSpeed;
            if (keys['ArrowRight']) playerX += playerSpeed;

            // Ensure player doesn't move outside the canvas boundaries
            if (playerX < 0) {
                playerX = 0;
            }
            if (playerX + playerSize > canvas.width) {
                playerX = canvas.width - playerSize;
            }

            if (keys['ArrowDown']) {
                isDucking = true;
                playerSize = 15;
            } else {
                isDucking = false;
                playerSize = 30;
            }

            if (keys['Space'] && !isJumping) {
                velocityY = -15;
                isJumping = true;
            }

            velocityY += gravity;
            playerY += velocityY;

            if (playerY >= canvas.height - playerSize) {
                playerY = canvas.height - playerSize;
                isJumping = false;
            }

            if (Math.random() < 0.01) {
                let isHighObstacle = Math.random() < 0.5;
                let onHill = Math.random() < 0.5;
                let obstacleSize;
                let obstacleX = canvas.width;
                let obstacleY;

                if (isHighObstacle) {
                    obstacleSize = 25;
                } else {
                    obstacleSize = 20;
                }

                if (onHill) {
                    obstacleY = canvas.height - getHillY(obstacleX) - obstacleSize;
                } else {
                    obstacleY = canvas.height - obstacleSize;
                }

                obstacles.push({
                    x: obstacleX,
                    y: obstacleY,
                    size: obstacleSize,
                    onHill: onHill
                });
            }

            obstacles.forEach((obstacle, i) => {
                obstacle.x -= playerSpeed;

                if (obstacle.onHill) {
                    obstacle.y = canvas.height - obstacle.size - getHillY(obstacle.x);
                }

                if (obstacle.x < -obstacle.size) {
                    obstacles.splice(i, 1);
                }

                if (
            playerX < obstacle.x + obstacle.size &&
            playerX + playerSize > obstacle.x &&
            playerY < obstacle.y + obstacle.size &&
            playerY + playerSize > obstacle.y
        ) {
            alert('Game Over');
            restartGame(); // Restart the game directly after collision is detected
        }
    });
}
        
        

        function draw() {
            context.clearRect(0, 0, canvas.width, canvas.height);

            drawBackground();

            context.fillStyle = '#0F0';
            context.beginPath();
            context.arc(playerX + playerSize / 2, playerY + playerSize / 2, playerSize / 2, 0, Math.PI * 2);
            context.fill();

            context.fillStyle = '#F00';
            obstacles.forEach(obstacle => {
                context.beginPath();
                context.arc(obstacle.x + obstacle.size / 2, obstacle.y + obstacle.size / 2, obstacle.size / 2, 0, Math.PI * 2);
                context.fill();
            });
        }

        function gameLoop() {
            update();
            draw();
            requestAnimationFrame(gameLoop);
        }

        function restartGame() {
    playerX = 50;
    playerY = canvas.height - 50;
    velocityY = 0;
    isJumping = false;
    isDucking = false;
    obstacles = [];
    keys = {};  // keysオブジェクトをクリアします
}

        document.getElementById('restartButton').addEventListener('click', restartGame);

        gameLoop();
    </script>
</body>

</html>
